<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Choose and Accept - COMP6203 Intelligent Agents 中文学习指南</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Choose and Accept";
    var mkdocs_page_input_path = "action.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> COMP6203 Intelligent Agents 中文学习指南</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../start/">Quick Start</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../basic/">Basic Concept (Lab1)</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../simple/">Simple Agent (Lab2)</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../opponent/">Opponent Model (Lab3)</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../user/">User Model (Lab4)</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Choose and Accept</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_2">出价</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_3">如何出价</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_4">如何实现出价的创新？</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_5">接受</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_6">如何接受</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#offer">接受offer的创新点</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_7">总结</a>
    </li>
    </ul>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">COMP6203 Intelligent Agents 中文学习指南</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Choose and Accept</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="_1">出价与接受的博弈</h1>
<p><img alt="winchester" src="../img/action/winchester.jpg" /></p>
<p>这一章节，我会讲一讲我的Agent是如何制定出价策略和接受策略的👀。</p>
<p>但是这一章节我并没有太多实质性的内容可以说，因为我自己认为我的出价和接受价格的策略其实考虑的非常不仔细。😞这可能是因为当时我并没有足够多的时间去考虑这个了，毕竟除了这个Agent大作业，还有计算机视觉的大作业连续需要完成。所以算是虎头蛇尾了。</p>
<p>😆但我的一些策略应该还是可以给你们提供一个比较清晰的思路。就当做是抛砖引玉了，说不定你们能想到很多刁钻的策略，刁钻到能够让我赞不绝口。</p>
<h2 id="_2">出价</h2>
<h3 id="_3">如何出价</h3>
<p>你出价的时候，会怎么出？</p>
<p>我的选择是从高到低，且分段进行。这里的分段是根据时间分段，而不是用一个统一的函数进行求值。至于为什么我用分段，那当然还是我一点一点测出来的。因为在正式提交之前，你们也会有一个小的 <a href="http://www.southampton.ac.uk/~eg/competition/">Mini Tournament</a>。这个小的Tournament是用你的agent和往届的agent比赛，从而测试你的agent的效果的。你每次提交完了之后会有结果，这个结果可以帮助你进行参数上的微调。</p>
<p>下面我会讲讲我的出价策略。可以看出我的出价策略代码非常的丑陋。。。这也是没办法的，当时时间紧凑，再加上不停的微调，所以根本不想在乎可读性了😂。</p>
<p>同时我现在读我的代码，也发现了一些问题。我会把这些问题抛出来，你们自己理解并且改进。</p>
<ol>
<li>
<p>当时间小于0.05的时候我选择不停出一张牌，来迷惑对手。当时想的是最高效用的Bid。但是现在想想，迷惑的想法是好的。但是用错了办法。因为对方大概率也是用Johny Black,所以我一直出最高效用的Bid,那会有什么情况发生呢？🤨</p>
</li>
<li>
<p>在时间小于0.4的时候，我会尽可能出一个给对方高的offer，但是这个offer不能比我的妥协值(Concession value)高0.05，也不能低于我的 Concession value-0.1。就是尽可能给他高的，但也不能太高。我当时的想法就是，一方面，尽可能让自己的每一次offer都能走在帕累托边界上，一方面也希望这个值能够接近纳什均衡点，即便我并不知道他在哪，但是我就估计他在我的Concession value附近。我承认，我有赌的的成分🍷。但是我也想不到更好的方法啦。</p>
</li>
<li>
<p>在高于0.4秒的时候，实际上只是将0.1改为了0.05。因为毕竟做人要厚道，对面死不妥协，那么我也不能逼他妥协。</p>
</li>
</ol>
<pre><code class="language-java">    private Bid generateRandomBidAboveTarget()
    {
        long numberOfPossibleBids=this.getDomain().getNumberOfPossibleBids();
        double time = getTimeLine().getTime();
        Bid randomBid;
        double util;
        double opponentUtility;

        List&lt;Bid&gt; randomBidList=new ArrayList&lt;&gt;();
        List&lt;Double&gt; utilList=new ArrayList&lt;&gt;();
        List&lt;Double&gt; opponentUtiList=new ArrayList&lt;&gt;();  //存放对应Bid的对手效用
        //刚开始一直发相同的bid迷惑对手。让对手无法计算自己的模型。
        if(time&lt;0.05){
            return maxBidForMe;
        }

        //尽可能给对手最高的bid,这个时候不需要考虑对手，因为此时的对手模型不准确。
        else if(time&lt;0.4){
            for(int k=0;k&lt;2*numberOfPossibleBids;k++){
                randomBid=generateRandomBid();
                util = predictAdditiveSpace.getUtility(randomBid);
                if(util&gt;concessionValue-0.1&amp;&amp;util&lt;concessionValue+0.05){
                    utilList.add(util);
                    opponentUtiList.add(iaMap.JBpredict(randomBid));
                    randomBidList.add(randomBid);
                }
            }
            //如果找不到满足条件的，就直接生成一个效用最大的
            if(utilList.size()==0){
                for(int t=0;t&lt;2*numberOfPossibleBids;t++){
                    randomBid=generateRandomBid();
                    randomBidList.add(randomBid);
                    utilList.add(predictAdditiveSpace.getUtility(randomBid));
                }
                //这里可以保证，即便上次2000次循环之后没找到自己想要的bid，也能返回一个效用大的bid出来。
                double maxUtility=Collections.max(utilList);
                int indexRandBid=utilList.indexOf(maxUtility);
                Bid suitableBid=randomBidList.get(indexRandBid);
                return suitableBid;
            }
            double maxUtility=Collections.max(utilList);
            int indexRandBid=utilList.indexOf(maxUtility);
            Bid suitableBid=randomBidList.get(indexRandBid);
            return suitableBid;
        }

        //努力给对手最大的bid。
        else{
            for(int k=0;k&lt;3*numberOfPossibleBids;k++){
                randomBid=generateRandomBid();
                util = predictAdditiveSpace.getUtility(randomBid);
                if(util&gt;concessionValue-0.05&amp;&amp;util&lt;concessionValue+0.05){
                    utilList.add(util);
                    opponentUtiList.add(iaMap.JBpredict(randomBid));
                    randomBidList.add(randomBid);
                }
            }
            //如果找不到满足条件的，就直接生成一个自己效用最大的
            if(utilList.size()==0){
                for(int t=0;t&lt;2*numberOfPossibleBids;t++){
                    randomBid=generateRandomBid();
                    randomBidList.add(randomBid);
                    utilList.add(predictAdditiveSpace.getUtility(randomBid));
                }
                //这里可以保证，即便上次2000次循环之后没找到自己想要的bid，也能返回一个效用大的bid出来。
                double maxUtility=Collections.max(utilList);
                int indexRandBid=utilList.indexOf(maxUtility);
                Bid suitableBid=randomBidList.get(indexRandBid);
                return suitableBid;
            }
            else{
                double opponentMax=Collections.max(opponentUtiList);
                System.out.println(&quot;对手最大的效用为：&quot;+opponentMax);

                int indexOpponent=opponentUtiList.indexOf(opponentMax);
                Bid suitableBid=randomBidList.get(indexOpponent);
                System.out.println(&quot;自己的效用为：&quot;+predictAdditiveSpace.getUtility(suitableBid));
                return suitableBid;
            }
        }

    }
</code></pre>
<h3 id="_4">如何实现出价的创新？</h3>
<p>这里我会说说有哪些点，你们可以创新。</p>
<ol>
<li>
<p>关于如何迷惑对手。现在你们已经知道了，大部分预测你的模型都是用的Johny Black，那么你能不能想出一个出价策略，用来迷惑对手且不暴露自己呢？</p>
</li>
<li>
<p>关于纳什均衡点，其实我猜的纳什均衡点是在0.8左右。但是这是不准确的。比如有没有方法，通过计算两个offer，一个offer是自己的最高值，对手的最低值，一个offer是自己的最低值，对手的最高值。然后将这两个点连接起来，最后取中点做圆，然后做垂线，垂线与圆的交点会不会更接近纳什均衡点？当然这都是我的想象啦。你们可以试试。</p>
</li>
<li>
<p>关于时间选择。对手可能在最后短暂的时间妥协，那么我们能不能也死扛到最后呢？当然也不能太后，不然对手一下出个离谱的价格，被你接受了，虽然utility你是高的，但是，你们报价远离纳什均衡点，那个分数会扣的很多噢。</p>
</li>
</ol>
<h2 id="_5">接受</h2>
<h3 id="_6">如何接受</h3>
<p>我的接受价格策略就更加暴力了。全分段函数，老方法，不停的调试参数。</p>
<p>为什么我采用这种方式？因为看了往届ANAC的比赛的代码，很多人都采用了这种类似的结构。可能这就是调参的玄学吧🤪。</p>
<p>说实话，我当时的脑袋已经是一团浆糊了，实在想不出什么高端的出价策略。但是，我还是通过最后的比赛结果，反应出了我接受offer的一些问题。</p>
<pre><code class="language-java">    @Override
    public Action chooseAction(List&lt;Class&lt;? extends Action&gt;&gt; possibleActions)
    {
        double time = getTimeLine().getTime();  //***    #这里的time是正规化[0,1]范围。是相对于round的数目
        System.out.println(&quot;时间是：&quot;+time);
        calculateConcession(time);  //通过时间来控制自己的阈值，底线

        if(lastOffer!=null){
            //坚决不接受高效用的offer。不然的话离纳什均衡点会很远。
            if(time&lt;0.3){
                if(predictAdditiveSpace.getUtility(lastOffer)&gt;concessionValue||predictAdditiveSpace.getUtility(lastOffer)&gt;0.88){
                    return new Accept(getPartyId(), lastOffer);
                }
                return new Offer(getPartyId(), generateRandomBidAboveTarget());
            }
            else if(time&lt;0.5){
                if(predictAdditiveSpace.getUtility(lastOffer)&gt;concessionValue||predictAdditiveSpace.getUtility(lastOffer)&gt;0.87){
                    return new Accept(getPartyId(), lastOffer);
                }
                return new Offer(getPartyId(), generateRandomBidAboveTarget());
            }
            else if(time&lt;0.7){
                if(predictAdditiveSpace.getUtility(lastOffer)&gt;concessionValue||predictAdditiveSpace.getUtility(lastOffer)&gt;0.85){
                    return new Accept(getPartyId(), lastOffer);
                }
                return new Offer(getPartyId(), generateRandomBidAboveTarget());
            }

            else if(time&lt;0.8){
                if(predictAdditiveSpace.getUtility(lastOffer)&gt;concessionValue||predictAdditiveSpace.getUtility(lastOffer)&gt;0.83){
                    return new Accept(getPartyId(), lastOffer);
                }
                return new Offer(getPartyId(), generateRandomBidAboveTarget());
            }
            else if(time&lt;0.85){
                if(predictAdditiveSpace.getUtility(lastOffer)&gt;concessionValue||predictAdditiveSpace.getUtility(lastOffer)&gt;0.8){
                    return new Accept(getPartyId(), lastOffer);
                }
                return new Offer(getPartyId(), generateRandomBidAboveTarget());
            }

            else if(time&lt;0.9){
                if(predictAdditiveSpace.getUtility(lastOffer)&gt;concessionValue||predictAdditiveSpace.getUtility(lastOffer)&gt;0.7){
                    return new Accept(getPartyId(), lastOffer);
                }
                return new Offer(getPartyId(), generateRandomBidAboveTarget());
            }

            else if(time&lt;0.93){
                if(predictAdditiveSpace.getUtility(lastOffer)&gt;concessionValue||predictAdditiveSpace.getUtility(lastOffer)&gt;iaMap.JBpredict(lastOffer)){
                    return new Accept(getPartyId(), lastOffer);
                }
                return new Offer(getPartyId(), generateRandomBidAboveTarget());
            }

            //如果你给的offer满足我的阈值，我就接受。。或者这个效用大于对手的效用（多大于0.1防止计算不准确）
            else if(time&lt;0.98){
                if(predictAdditiveSpace.getUtility(lastOffer)&gt;concessionValue||predictAdditiveSpace.getUtility(lastOffer)&gt;iaMap.JBpredict(lastOffer)){
                    System.out.println(&quot;对手：&quot;+iaMap.JBpredict(lastOffer));
                    System.out.println(&quot;自己：&quot;+predictAdditiveSpace.getUtility(lastOffer));
                    return new Accept(getPartyId(), lastOffer);
                }
                return new Offer(getPartyId(), generateRandomBidAboveTarget());
            }
            //最后时刻直接妥协了。
            else {
                return new Accept(getPartyId(), lastOffer);
            }
        }
        //直接结束。
        return new Offer(getPartyId(), generateRandomBidAboveTarget());
</code></pre>
<h3 id="offer">接受offer的创新点</h3>
<ol>
<li>上面我提到了我的agent的问题，那么具体是什么问题呢？就是太软弱，太不aggressive了。为什么这么说呢？这里要给一个干货干货干货🐩！当时我把我的agent调参调的太容易妥协了。要知道，很多时候，不达成协议，就不得分，但是好像最后的比赛，不达成协议是件很正常的事，好像就不会算入平均得分。这也就意味着，你不一定每次都要达成协议。那么我为什么调成这样呢？都是因为参加mini tournament的时候，我18个比赛，经常只能完成17个，因为往年有个叫AgentGP的Agent，他总是跟我死刚到底。而且他的计算非常非常慢(GP的意思是Gaussian Process，你们下学期的FAI会学到，或者有人本科学过随机过程，差不多就是那个意思。)我为了和他完成negotiation，不停的调妥协，但是最后的比赛的数据分析告诉我，没那个必要哦🐌。</li>
</ol>
<p>2。 注意，你也不能太aggressive，不然你也很多玩不成。现在回想起来，还是把重心放在最后的0.1时间内。为什么呢？因为大部分人都会在这个时间段开始妥协，这也是最容易靠近纳什均衡点和拿高utility的机会(至少我是这么觉得的)🕸</p>
<h2 id="_7">总结</h2>
<p>这一章节，我还是比较惭愧只能给你们一个思路或者方向，具体的调试还是得靠你们自己啦。凡是要相信自己，要去试，试了不成功，记下来，写在report里，告诉老师你尝试了什么，为什么不成功，可以如何改进啥的，老师一般比较喜欢看这个。</p>
<p>接下来的一章，可能我会讲最后如何打包成老师需要的格式提交给服务器去测试，以及如何写一篇好的report。暂时只能想到这些啦。估计下一章也是最后一章啦，加油。</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../user/" class="btn btn-neutral" title="User Model (Lab4)"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../user/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../javascripts/config.js" defer></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6" defer></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
